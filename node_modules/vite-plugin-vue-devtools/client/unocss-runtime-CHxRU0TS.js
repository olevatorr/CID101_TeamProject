const Fe = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/, Ve = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/, He = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function Ge(e, t) {
  if (e === "__proto__" || e === "constructor" && t && typeof t == "object" && "prototype" in t) {
    Be(e);
    return;
  }
  return t;
}
function Be(e) {
  console.warn(`[destr] Dropping "${e}" key to prevent prototype pollution.`);
}
function ze(e, t = {}) {
  if (typeof e != "string")
    return e;
  const n = e.trim();
  if (
    // eslint-disable-next-line unicorn/prefer-at
    e[0] === '"' && e.endsWith('"') && !e.includes("\\")
  )
    return n.slice(1, -1);
  if (n.length <= 9) {
    const s = n.toLowerCase();
    if (s === "true")
      return !0;
    if (s === "false")
      return !1;
    if (s === "undefined")
      return;
    if (s === "null")
      return null;
    if (s === "nan")
      return Number.NaN;
    if (s === "infinity")
      return Number.POSITIVE_INFINITY;
    if (s === "-infinity")
      return Number.NEGATIVE_INFINITY;
  }
  if (!He.test(e)) {
    if (t.strict)
      throw new SyntaxError("[destr] Invalid JSON");
    return e;
  }
  try {
    if (Fe.test(e) || Ve.test(e)) {
      if (t.strict)
        throw new Error("[destr] Possible prototype pollution");
      return JSON.parse(e, Ge);
    }
    return JSON.parse(e);
  } catch (s) {
    if (t.strict)
      throw s;
    return e;
  }
}
const qe = /#/g, We = /&/g, Ke = /\//g, Je = /=/g, se = /\+/g, Xe = /%5e/gi, Qe = /%60/gi, Ye = /%7c/gi, Ze = /%20/gi;
function et(e) {
  return encodeURI("" + e).replace(Ye, "|");
}
function ee(e) {
  return et(typeof e == "string" ? e : JSON.stringify(e)).replace(se, "%2B").replace(Ze, "+").replace(qe, "%23").replace(We, "%26").replace(Qe, "`").replace(Xe, "^").replace(Ke, "%2F");
}
function J(e) {
  return ee(e).replace(Je, "%3D");
}
function Ee(e = "") {
  try {
    return decodeURIComponent("" + e);
  } catch {
    return "" + e;
  }
}
function tt(e) {
  return Ee(e.replace(se, " "));
}
function nt(e) {
  return Ee(e.replace(se, " "));
}
function st(e = "") {
  const t = {};
  e[0] === "?" && (e = e.slice(1));
  for (const n of e.split("&")) {
    const s = n.match(/([^=]+)=?(.*)/) || [];
    if (s.length < 2)
      continue;
    const o = tt(s[1]);
    if (o === "__proto__" || o === "constructor")
      continue;
    const r = nt(s[2] || "");
    t[o] === void 0 ? t[o] = r : Array.isArray(t[o]) ? t[o].push(r) : t[o] = [t[o], r];
  }
  return t;
}
function ot(e, t) {
  return (typeof t == "number" || typeof t == "boolean") && (t = String(t)), t ? Array.isArray(t) ? t.map((n) => `${J(e)}=${ee(n)}`).join("&") : `${J(e)}=${ee(t)}` : J(e);
}
function rt(e) {
  return Object.keys(e).filter((t) => e[t] !== void 0).map((t) => ot(t, e[t])).filter(Boolean).join("&");
}
const it = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/, at = /^[\s\w\0+.-]{2,}:([/\\]{2})?/, ct = /^([/\\]\s*){2,}[^/\\]/, lt = /\/$|\/\?|\/#/, ut = /^\.?\//;
function xe(e, t = {}) {
  return typeof t == "boolean" && (t = { acceptRelative: t }), t.strict ? it.test(e) : at.test(e) || (t.acceptRelative ? ct.test(e) : !1);
}
function te(e = "", t) {
  return t ? lt.test(e) : e.endsWith("/");
}
function ft(e = "", t) {
  if (!t)
    return (te(e) ? e.slice(0, -1) : e) || "/";
  if (!te(e, !0))
    return e || "/";
  let n = e, s = "";
  const o = e.indexOf("#");
  o >= 0 && (n = e.slice(0, o), s = e.slice(o));
  const [r, ...a] = n.split("?");
  return ((r.endsWith("/") ? r.slice(0, -1) : r) || "/") + (a.length > 0 ? `?${a.join("?")}` : "") + s;
}
function pt(e = "", t) {
  if (!t)
    return e.endsWith("/") ? e : e + "/";
  if (te(e, !0))
    return e || "/";
  let n = e, s = "";
  const o = e.indexOf("#");
  if (o >= 0 && (n = e.slice(0, o), s = e.slice(o), !n))
    return s;
  const [r, ...a] = n.split("?");
  return r + "/" + (a.length > 0 ? `?${a.join("?")}` : "") + s;
}
function dt(e, t) {
  if (ht(t) || xe(e))
    return e;
  const n = ft(t);
  return e.startsWith(n) ? e : gt(n, e);
}
function mt(e, t) {
  const n = Ce(e), s = { ...st(n.search), ...t };
  return n.search = rt(s), yt(n);
}
function ht(e) {
  return !e || e === "/";
}
function _t(e) {
  return e && e !== "/";
}
function gt(e, ...t) {
  let n = e || "";
  for (const s of t.filter((o) => _t(o)))
    if (n) {
      const o = s.replace(ut, "");
      n = pt(n) + o;
    } else
      n = s;
  return n;
}
const Ae = Symbol.for("ufo:protocolRelative");
function Ce(e = "", t) {
  const n = e.match(
    /^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i
  );
  if (n) {
    const [, u, d = ""] = n;
    return {
      protocol: u.toLowerCase(),
      pathname: d,
      href: u + d,
      auth: "",
      host: "",
      search: "",
      hash: ""
    };
  }
  if (!xe(e, { acceptRelative: !0 }))
    return t ? Ce(t + e) : ae(e);
  const [, s = "", o, r = ""] = e.replace(/\\/g, "/").match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || [], [, a = "", l = ""] = r.match(/([^#/?]*)(.*)?/) || [], { pathname: c, search: f, hash: i } = ae(
    l.replace(/\/(?=[A-Za-z]:)/, "")
  );
  return {
    protocol: s.toLowerCase(),
    auth: o ? o.slice(0, Math.max(0, o.length - 1)) : "",
    host: a,
    pathname: c,
    search: f,
    hash: i,
    [Ae]: !s
  };
}
function ae(e = "") {
  const [t = "", n = "", s = ""] = (e.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1);
  return {
    pathname: t,
    search: n,
    hash: s
  };
}
function yt(e) {
  const t = e.pathname || "", n = e.search ? (e.search.startsWith("?") ? "" : "?") + e.search : "", s = e.hash || "", o = e.auth ? e.auth + "@" : "", r = e.host || "";
  return (e.protocol || e[Ae] ? (e.protocol || "") + "//" : "") + o + r + t + n + s;
}
class bt extends Error {
  constructor(t, n) {
    super(t, n), this.name = "FetchError", n != null && n.cause && !this.cause && (this.cause = n.cause);
  }
}
function vt(e) {
  var c, f, i, u, d;
  const t = ((c = e.error) == null ? void 0 : c.message) || ((f = e.error) == null ? void 0 : f.toString()) || "", n = ((i = e.request) == null ? void 0 : i.method) || ((u = e.options) == null ? void 0 : u.method) || "GET", s = ((d = e.request) == null ? void 0 : d.url) || String(e.request) || "/", o = `[${n}] ${JSON.stringify(s)}`, r = e.response ? `${e.response.status} ${e.response.statusText}` : "<no response>", a = `${o}: ${r}${t ? ` ${t}` : ""}`, l = new bt(
    a,
    e.error ? { cause: e.error } : void 0
  );
  for (const m of ["request", "options", "response"])
    Object.defineProperty(l, m, {
      get() {
        return e[m];
      }
    });
  for (const [m, h] of [
    ["data", "_data"],
    ["status", "status"],
    ["statusCode", "status"],
    ["statusText", "statusText"],
    ["statusMessage", "statusText"]
  ])
    Object.defineProperty(l, m, {
      get() {
        return e.response && e.response[h];
      }
    });
  return l;
}
const wt = new Set(
  Object.freeze(["PATCH", "POST", "PUT", "DELETE"])
);
function ce(e = "GET") {
  return wt.has(e.toUpperCase());
}
function St(e) {
  if (e === void 0)
    return !1;
  const t = typeof e;
  return t === "string" || t === "number" || t === "boolean" || t === null ? !0 : t !== "object" ? !1 : Array.isArray(e) ? !0 : e.buffer ? !1 : e.constructor && e.constructor.name === "Object" || typeof e.toJSON == "function";
}
const Et = /* @__PURE__ */ new Set([
  "image/svg",
  "application/xml",
  "application/xhtml",
  "application/html"
]), xt = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;
function At(e = "") {
  if (!e)
    return "json";
  const t = e.split(";").shift() || "";
  return xt.test(t) ? "json" : Et.has(t) || t.startsWith("text/") ? "text" : "blob";
}
function Ct(e, t, n = globalThis.Headers) {
  const s = {
    ...t,
    ...e
  };
  if (t != null && t.params && (e != null && e.params) && (s.params = {
    ...t == null ? void 0 : t.params,
    ...e == null ? void 0 : e.params
  }), t != null && t.query && (e != null && e.query) && (s.query = {
    ...t == null ? void 0 : t.query,
    ...e == null ? void 0 : e.query
  }), t != null && t.headers && (e != null && e.headers)) {
    s.headers = new n((t == null ? void 0 : t.headers) || {});
    for (const [o, r] of new n((e == null ? void 0 : e.headers) || {}))
      s.headers.set(o, r);
  }
  return s;
}
const Ot = /* @__PURE__ */ new Set([
  408,
  // Request Timeout
  409,
  // Conflict
  425,
  // Too Early
  429,
  // Too Many Requests
  500,
  // Internal Server Error
  502,
  // Bad Gateway
  503,
  // Service Unavailable
  504
  //  Gateway Timeout
]), kt = /* @__PURE__ */ new Set([101, 204, 205, 304]);
function Oe(e = {}) {
  const {
    fetch: t = globalThis.fetch,
    Headers: n = globalThis.Headers,
    AbortController: s = globalThis.AbortController
  } = e;
  async function o(l) {
    const c = l.error && l.error.name === "AbortError" && !l.options.timeout || !1;
    if (l.options.retry !== !1 && !c) {
      let i;
      typeof l.options.retry == "number" ? i = l.options.retry : i = ce(l.options.method) ? 0 : 1;
      const u = l.response && l.response.status || 500;
      if (i > 0 && (Array.isArray(l.options.retryStatusCodes) ? l.options.retryStatusCodes.includes(u) : Ot.has(u))) {
        const d = l.options.retryDelay || 0;
        return d > 0 && await new Promise((m) => setTimeout(m, d)), r(l.request, {
          ...l.options,
          retry: i - 1
        });
      }
    }
    const f = vt(l);
    throw Error.captureStackTrace && Error.captureStackTrace(f, r), f;
  }
  const r = async function(c, f = {}) {
    var m;
    const i = {
      request: c,
      options: Ct(f, e.defaults, n),
      response: void 0,
      error: void 0
    };
    i.options.method = (m = i.options.method) == null ? void 0 : m.toUpperCase(), i.options.onRequest && await i.options.onRequest(i), typeof i.request == "string" && (i.options.baseURL && (i.request = dt(i.request, i.options.baseURL)), (i.options.query || i.options.params) && (i.request = mt(i.request, {
      ...i.options.params,
      ...i.options.query
    }))), i.options.body && ce(i.options.method) && (St(i.options.body) ? (i.options.body = typeof i.options.body == "string" ? i.options.body : JSON.stringify(i.options.body), i.options.headers = new n(i.options.headers || {}), i.options.headers.has("content-type") || i.options.headers.set("content-type", "application/json"), i.options.headers.has("accept") || i.options.headers.set("accept", "application/json")) : (
      // ReadableStream Body
      ("pipeTo" in i.options.body && typeof i.options.body.pipeTo == "function" || // Node.js Stream Body
      typeof i.options.body.pipe == "function") && ("duplex" in i.options || (i.options.duplex = "half"))
    ));
    let u;
    if (!i.options.signal && i.options.timeout) {
      const h = new s();
      u = setTimeout(
        () => h.abort(),
        i.options.timeout
      ), i.options.signal = h.signal;
    }
    try {
      i.response = await t(
        i.request,
        i.options
      );
    } catch (h) {
      return i.error = h, i.options.onRequestError && await i.options.onRequestError(i), await o(i);
    } finally {
      u && clearTimeout(u);
    }
    if (i.response.body && !kt.has(i.response.status) && i.options.method !== "HEAD") {
      const h = (i.options.parseResponse ? "json" : i.options.responseType) || At(i.response.headers.get("content-type") || "");
      switch (h) {
        case "json": {
          const _ = await i.response.text(), b = i.options.parseResponse || ze;
          i.response._data = b(_);
          break;
        }
        case "stream": {
          i.response._data = i.response.body;
          break;
        }
        default:
          i.response._data = await i.response[h]();
      }
    }
    return i.options.onResponse && await i.options.onResponse(i), !i.options.ignoreResponseError && i.response.status >= 400 && i.response.status < 600 ? (i.options.onResponseError && await i.options.onResponseError(i), await o(i)) : i.response;
  }, a = async function(c, f) {
    return (await r(c, f))._data;
  };
  return a.raw = r, a.native = (...l) => t(...l), a.create = (l = {}) => Oe({
    ...e,
    defaults: {
      ...e.defaults,
      ...l
    }
  }), a;
}
const oe = function() {
  if (typeof globalThis < "u")
    return globalThis;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global < "u")
    return global;
  throw new Error("unable to locate global object");
}(), Rt = oe.fetch || (() => Promise.reject(new Error("[ofetch] global.fetch is not supported!"))), Tt = oe.Headers, $t = oe.AbortController, Mt = Oe({ fetch: Rt, Headers: Tt, AbortController: $t }), Lt = Mt;
function Ut(e) {
  const t = e.length;
  let n = -1, s, o = "";
  const r = e.charCodeAt(0);
  for (; ++n < t; ) {
    if (s = e.charCodeAt(n), s === 0) {
      o += "�";
      continue;
    }
    if (s === 37) {
      o += "\\%";
      continue;
    }
    if (s === 44) {
      o += "\\,";
      continue;
    }
    if (
      // If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
      // U+007F, […]
      s >= 1 && s <= 31 || s === 127 || n === 0 && s >= 48 && s <= 57 || n === 1 && s >= 48 && s <= 57 && r === 45
    ) {
      o += `\\${s.toString(16)} `;
      continue;
    }
    if (
      // If the character is the first character and is a `-` (U+002D), and
      // there is no second character, […]
      n === 0 && t === 1 && s === 45
    ) {
      o += `\\${e.charAt(n)}`;
      continue;
    }
    if (s >= 128 || s === 45 || s === 95 || s >= 48 && s <= 57 || s >= 65 && s <= 90 || s >= 97 && s <= 122) {
      o += e.charAt(n);
      continue;
    }
    o += `\\${e.charAt(n)}`;
  }
  return o;
}
const X = Ut;
function I(e = []) {
  return Array.isArray(e) ? e : [e];
}
function W(e) {
  return Array.from(new Set(e));
}
function It(e, t) {
  return e.reduce((n, s) => (n.findIndex((r) => t(s, r)) === -1 && n.push(s), n), []);
}
function L(e) {
  return typeof e == "string";
}
function H(e) {
  return L(e) ? e : (Array.isArray(e) ? e : Object.entries(e)).filter((t) => t[1] != null);
}
function Nt(e) {
  return Array.isArray(e) ? e.find((t) => !Array.isArray(t) || Array.isArray(t[0])) ? e.map((t) => H(t)) : [e] : [H(e)];
}
function Dt(e) {
  return e.filter(([t, n], s) => {
    if (t.startsWith("$$"))
      return !1;
    for (let o = s - 1; o >= 0; o--)
      if (e[o][0] === t && e[o][1] === n)
        return !1;
    return !0;
  });
}
function Q(e) {
  return e == null ? "" : Dt(e).map(([t, n]) => n != null ? `${t}:${n};` : void 0).filter(Boolean).join("");
}
function G(e) {
  return e && typeof e == "object" && !Array.isArray(e);
}
function ke(e, t, n = !1) {
  const s = e, o = t;
  if (Array.isArray(o))
    return n && Array.isArray(o) ? [...s, ...o] : [...o];
  const r = { ...s };
  return G(s) && G(o) && Object.keys(o).forEach((a) => {
    G(s[a]) && G(o[a]) || Array.isArray(s[a]) && Array.isArray(o[a]) ? r[a] = ke(s[a], o[a], n) : Object.assign(r, { [a]: o[a] });
  }), r;
}
function z(e) {
  let t, n, s;
  if (Array.isArray(e)) {
    for (n = Array(t = e.length); t--; )
      n[t] = (s = e[t]) && typeof s == "object" ? z(s) : s;
    return n;
  }
  if (Object.prototype.toString.call(e) === "[object Object]") {
    n = {};
    for (t in e)
      t === "__proto__" ? Object.defineProperty(n, t, {
        value: z(e[t]),
        configurable: !0,
        enumerable: !0,
        writable: !0
      }) : n[t] = (s = e[t]) && typeof s == "object" ? z(s) : s;
    return n;
  }
  return e;
}
function jt(e) {
  return L(e[0]);
}
function Pt(e) {
  return L(e[0]);
}
const le = "$$shortcut-no-merge";
function Ft(e) {
  return typeof e == "function" ? { match: e } : e;
}
function ue(e) {
  return e.length === 3;
}
function Vt(e) {
  return e != null;
}
function Ht() {
}
var Gt = Object.defineProperty, Bt = (e, t, n) => t in e ? Gt(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, zt = (e, t, n) => (Bt(e, t + "", n), n);
class qt {
  constructor() {
    zt(this, "_map", /* @__PURE__ */ new Map());
  }
  get(t, n) {
    const s = this._map.get(t);
    if (s)
      return s.get(n);
  }
  getFallback(t, n, s) {
    let o = this._map.get(t);
    return o || (o = /* @__PURE__ */ new Map(), this._map.set(t, o)), o.has(n) || o.set(n, s), o.get(n);
  }
  set(t, n, s) {
    let o = this._map.get(t);
    return o || (o = /* @__PURE__ */ new Map(), this._map.set(t, o)), o.set(n, s), this;
  }
  has(t, n) {
    var s;
    return (s = this._map.get(t)) == null ? void 0 : s.has(n);
  }
  delete(t, n) {
    var s;
    return ((s = this._map.get(t)) == null ? void 0 : s.delete(n)) || !1;
  }
  deleteTop(t) {
    return this._map.delete(t);
  }
  map(t) {
    return Array.from(this._map.entries()).flatMap(([n, s]) => Array.from(s.entries()).map(([o, r]) => t(r, n, o)));
  }
}
class Wt extends Map {
  getFallback(t, n) {
    const s = this.get(t);
    return s === void 0 ? (this.set(t, n), n) : s;
  }
  map(t) {
    const n = [];
    return this.forEach((s, o) => {
      n.push(t(s, o));
    }), n;
  }
  flatMap(t) {
    const n = [];
    return this.forEach((s, o) => {
      n.push(...t(s, o));
    }), n;
  }
}
var Kt = Object.defineProperty, Jt = (e, t, n) => t in e ? Kt(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Xt = (e, t, n) => (Jt(e, t + "", n), n);
class Re extends Set {
  constructor(t) {
    super(t), Xt(this, "_map"), this._map ?? (this._map = /* @__PURE__ */ new Map());
  }
  add(t) {
    return this._map ?? (this._map = /* @__PURE__ */ new Map()), this._map.set(t, (this._map.get(t) ?? 0) + 1), super.add(t);
  }
  delete(t) {
    return this._map.delete(t), super.delete(t);
  }
  clear() {
    this._map.clear(), super.clear();
  }
  getCount(t) {
    return this._map.get(t) ?? 0;
  }
  setCount(t, n) {
    return this._map.set(t, n), super.add(t);
  }
}
function Y(e) {
  return e instanceof Re;
}
const B = {};
function Qt(e = ["-", ":"]) {
  const t = e.join("|");
  return B[t] || (B[t] = new RegExp(`((?:[!@<~\\w+:_/-]|\\[&?>?:?\\S*\\])+?)(${t})\\(((?:[~!<>\\w\\s:/\\\\,%#.$?-]|\\[.*?\\])+?)\\)(?!\\s*?=>)`, "gm")), B[t].lastIndex = 0, B[t];
}
function Yt(e, t = ["-", ":"], n = 5) {
  const s = Qt(t);
  let o, r = e.toString();
  const a = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Map();
  do
    o = !1, r = r.replace(
      s,
      (f, i, u, d, m) => {
        var b;
        if (!t.includes(u))
          return f;
        o = !0, a.add(i + u);
        const h = m + i.length + u.length + 1, _ = { length: f.length, items: [] };
        l.set(m, _);
        for (const C of [...d.matchAll(/\S+/g)]) {
          const A = h + C.index;
          let g = (b = l.get(A)) == null ? void 0 : b.items;
          g ? l.delete(A) : g = [{
            offset: A,
            length: C[0].length,
            className: C[0]
          }];
          for (const S of g)
            S.className = S.className === "~" ? i : S.className.replace(/^(!?)(.*)/, `$1${i}${u}$2`), _.items.push(S);
        }
        return "$".repeat(f.length);
      }
    ), n -= 1;
  while (o && n);
  let c;
  if (typeof e == "string") {
    c = "";
    let f = 0;
    for (const [i, u] of l)
      c += e.slice(f, i), c += u.items.map((d) => d.className).join(" "), f = i + u.length;
    c += e.slice(f);
  } else {
    c = e;
    for (const [f, i] of l)
      c.overwrite(
        f,
        f + i.length,
        i.items.map((u) => u.className).join(" ")
      );
  }
  return {
    prefixes: Array.from(a),
    hasChanged: o,
    groupsByOffset: l,
    // Computed lazily because MagicString's toString does a lot of work
    get expanded() {
      return c.toString();
    }
  };
}
function Zt(e, t = ["-", ":"], n = 5) {
  const s = Yt(e, t, n);
  return typeof e == "string" ? s.expanded : e;
}
const fe = /* @__PURE__ */ new Set();
function Te(e) {
  fe.has(e) || (console.warn("[unocss]", e), fe.add(e));
}
const en = /[\\:]?[\s'"`;{}]+/g;
function tn(e) {
  return e.split(en);
}
const nn = {
  name: "@unocss/core/extractor-split",
  order: 0,
  extract({ code: e }) {
    return tn(e);
  }
};
function sn() {
  return {
    events: {},
    emit(e, ...t) {
      (this.events[e] || []).forEach((n) => n(...t));
    },
    on(e, t) {
      return (this.events[e] = this.events[e] || []).push(t), () => this.events[e] = (this.events[e] || []).filter((n) => n !== t);
    }
  };
}
const q = "default", ne = "preflights", on = "shortcuts", rn = "imports", an = {
  [rn]: -200,
  [ne]: -100,
  [on]: -10,
  [q]: 0
};
function $e(e) {
  return I(e).flatMap((t) => Array.isArray(t) ? [t] : Object.entries(t));
}
const pe = "_uno_resolved";
function cn(e) {
  var s;
  let t = typeof e == "function" ? e() : e;
  if (pe in t)
    return t;
  t = { ...t }, Object.defineProperty(t, pe, {
    value: !0,
    enumerable: !1
  });
  const n = t.shortcuts ? $e(t.shortcuts) : void 0;
  if (t.shortcuts = n, t.prefix || t.layer) {
    const o = (r) => {
      r[2] || (r[2] = {});
      const a = r[2];
      a.prefix == null && t.prefix && (a.prefix = I(t.prefix)), a.layer == null && t.layer && (a.layer = t.layer);
    };
    n == null || n.forEach(o), (s = t.rules) == null || s.forEach(o);
  }
  return t;
}
function Me(e) {
  const t = cn(e);
  if (!t.presets)
    return [t];
  const n = (t.presets || []).flatMap(I).flatMap(Me);
  return [t, ...n];
}
function de(e = {}, t = {}) {
  var S, w;
  const n = Object.assign({}, t, e), s = It((n.presets || []).flatMap(I).flatMap(Me), (p, v) => p.name === v.name), o = [
    ...s.filter((p) => p.enforce === "pre"),
    ...s.filter((p) => !p.enforce),
    ...s.filter((p) => p.enforce === "post")
  ], r = [
    ...o,
    n
  ], a = [...r].reverse(), l = Object.assign({}, an, ...r.map((p) => p.layers));
  function c(p) {
    return W(r.flatMap((v) => I(v[p] || [])));
  }
  const f = c("extractors");
  let i = (S = a.find((p) => p.extractorDefault !== void 0)) == null ? void 0 : S.extractorDefault;
  i === void 0 && (i = nn), i && !f.includes(i) && f.unshift(i), f.sort((p, v) => (p.order || 0) - (v.order || 0));
  const u = c("rules"), d = {}, m = u.length, h = u.map((p, v) => {
    var k;
    if (jt(p)) {
      I(((k = p[2]) == null ? void 0 : k.prefix) || "").forEach((T) => {
        d[T + p[0]] = [v, p[1], p[2], p];
      });
      return;
    }
    return [v, ...p];
  }).filter(Boolean).reverse();
  let _ = ln(r.map((p) => p.theme));
  const b = c("extendTheme");
  for (const p of b)
    _ = p(_) || _;
  const C = {
    templates: W(r.flatMap((p) => {
      var v;
      return I((v = p.autocomplete) == null ? void 0 : v.templates);
    })),
    extractors: r.flatMap((p) => {
      var v;
      return I((v = p.autocomplete) == null ? void 0 : v.extractors);
    }).sort((p, v) => (p.order || 0) - (v.order || 0)),
    shorthands: un(r.map((p) => {
      var v;
      return ((v = p.autocomplete) == null ? void 0 : v.shorthands) || {};
    }))
  };
  let A = c("separators");
  A.length || (A = [":", "-"]);
  const g = {
    mergeSelectors: !0,
    warn: !0,
    sortLayers: (p) => p,
    ...n,
    blocklist: c("blocklist"),
    presets: o,
    envMode: n.envMode || "build",
    shortcutsLayer: n.shortcutsLayer || "shortcuts",
    layers: l,
    theme: _,
    rulesSize: m,
    rulesDynamic: h,
    rulesStaticMap: d,
    preprocess: c("preprocess"),
    postprocess: c("postprocess"),
    preflights: c("preflights"),
    autocomplete: C,
    variants: c("variants").map(Ft).sort((p, v) => (p.order || 0) - (v.order || 0)),
    shortcuts: $e(c("shortcuts")).reverse(),
    extractors: f,
    safelist: c("safelist"),
    separators: A,
    details: n.details ?? n.envMode === "dev"
  };
  for (const p of r)
    (w = p == null ? void 0 : p.configResolved) == null || w.call(p, g);
  return g;
}
function ln(e) {
  return e.map((t) => t ? z(t) : {}).reduce((t, n) => ke(t, n), {});
}
function un(e) {
  return e.reduce((t, n) => {
    const s = {};
    for (const o in n) {
      const r = n[o];
      Array.isArray(r) ? s[o] = `(${r.join("|")})` : s[o] = r;
    }
    return {
      ...t,
      ...s
    };
  }, {});
}
const fn = "0.60.2";
var pn = Object.defineProperty, dn = (e, t, n) => t in e ? pn(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, j = (e, t, n) => (dn(e, typeof t != "symbol" ? t + "" : t, n), n);
class mn {
  constructor(t = {}, n = {}) {
    this.userConfig = t, this.defaults = n, j(this, "version", fn), j(this, "_cache", /* @__PURE__ */ new Map()), j(this, "config"), j(this, "blocked", /* @__PURE__ */ new Set()), j(this, "parentOrders", /* @__PURE__ */ new Map()), j(this, "events", sn()), this.config = de(t, n), this.events.emit("config", this.config);
  }
  setConfig(t, n) {
    t && (n && (this.defaults = n), this.userConfig = t, this.blocked.clear(), this.parentOrders.clear(), this._cache.clear(), this.config = de(t, this.defaults), this.events.emit("config", this.config));
  }
  async applyExtractors(t, n, s = /* @__PURE__ */ new Set()) {
    var r;
    const o = {
      original: t,
      code: t,
      id: n,
      extracted: s,
      envMode: this.config.envMode
    };
    for (const a of this.config.extractors) {
      const l = await ((r = a.extract) == null ? void 0 : r.call(a, o));
      if (l)
        if (Y(l) && Y(s))
          for (const c of l)
            s.setCount(c, s.getCount(c) + l.getCount(c));
        else
          for (const c of l)
            s.add(c);
    }
    return s;
  }
  makeContext(t, n) {
    const s = {
      rawSelector: t,
      currentSelector: n[1],
      theme: this.config.theme,
      generator: this,
      variantHandlers: n[2],
      constructCSS: (...o) => this.constructCustomCSS(s, ...o),
      variantMatch: n
    };
    return s;
  }
  async parseToken(t, n) {
    var f;
    if (this.blocked.has(t))
      return;
    const s = `${t}${n ? ` ${n}` : ""}`;
    if (this._cache.has(s))
      return this._cache.get(s);
    let o = t;
    for (const i of this.config.preprocess)
      o = i(t);
    if (this.isBlocked(o)) {
      this.blocked.add(t), this._cache.set(s, null);
      return;
    }
    const r = await this.matchVariants(t, o);
    if (!r || this.isBlocked(r[1])) {
      this.blocked.add(t), this._cache.set(s, null);
      return;
    }
    const a = this.makeContext(t, [n || r[0], r[1], r[2], r[3]]);
    this.config.details && (a.variants = [...r[3]]);
    const l = await this.expandShortcut(a.currentSelector, a), c = l ? await this.stringifyShortcuts(a.variantMatch, a, l[0], l[1]) : (f = await this.parseUtil(a.variantMatch, a)) == null ? void 0 : f.map((i) => this.stringifyUtil(i, a)).filter(Vt);
    if (c != null && c.length)
      return this._cache.set(s, c), c;
    this._cache.set(s, null);
  }
  async generate(t, n = {}) {
    const {
      id: s,
      scope: o,
      preflights: r = !0,
      safelist: a = !0,
      minify: l = !1,
      extendedInfo: c = !1
    } = n, f = this.config.outputToCssLayers, i = L(t) ? await this.applyExtractors(
      t,
      s,
      c ? new Re() : /* @__PURE__ */ new Set()
    ) : Array.isArray(t) ? new Set(t) : t;
    if (a) {
      const w = {
        generator: this,
        theme: this.config.theme
      };
      this.config.safelist.flatMap((p) => typeof p == "function" ? p(w) : p).forEach((p) => {
        i.has(p) || i.add(p);
      });
    }
    const u = l ? "" : `
`, d = /* @__PURE__ */ new Set([q]), m = c ? /* @__PURE__ */ new Map() : /* @__PURE__ */ new Set(), h = /* @__PURE__ */ new Map();
    let _ = {};
    const b = Array.from(i).map(async (w) => {
      var v;
      if (m.has(w))
        return;
      const p = await this.parseToken(w);
      if (p != null) {
        m instanceof Map ? m.set(w, {
          data: p,
          count: Y(i) ? i.getCount(w) : -1
        }) : m.add(w);
        for (const k of p) {
          const O = k[3] || "", T = (v = k[4]) == null ? void 0 : v.layer;
          h.has(O) || h.set(O, []), h.get(O).push(k), T && d.add(T);
        }
      }
    });
    await Promise.all(b), await (async () => {
      if (!r)
        return;
      const w = {
        generator: this,
        theme: this.config.theme
      }, p = /* @__PURE__ */ new Set([]);
      this.config.preflights.forEach(({ layer: v = ne }) => {
        d.add(v), p.add(v);
      }), _ = Object.fromEntries(
        await Promise.all(Array.from(p).map(
          async (v) => {
            const O = (await Promise.all(
              this.config.preflights.filter((T) => (T.layer || ne) === v).map(async (T) => await T.getCSS(w))
            )).filter(Boolean).join(u);
            return [v, O];
          }
        ))
      );
    })();
    const C = this.config.sortLayers(Array.from(d).sort((w, p) => (this.config.layers[w] ?? 0) - (this.config.layers[p] ?? 0) || w.localeCompare(p))), A = {}, g = (w = q) => {
      var k;
      if (A[w])
        return A[w];
      let p = Array.from(h).sort((O, T) => {
        var N;
        return (this.parentOrders.get(O[0]) ?? 0) - (this.parentOrders.get(T[0]) ?? 0) || ((N = O[0]) == null ? void 0 : N.localeCompare(T[0] || "")) || 0;
      }).map(([O, T]) => {
        const N = T.length, D = T.filter((R) => {
          var y;
          return (((y = R[4]) == null ? void 0 : y.layer) || q) === w;
        }).sort((R, y) => {
          var E, x, U, $, M, V, ie;
          return R[0] - y[0] || (((E = R[4]) == null ? void 0 : E.sort) || 0) - (((x = y[4]) == null ? void 0 : x.sort) || 0) || ((M = (U = R[5]) == null ? void 0 : U.currentSelector) == null ? void 0 : M.localeCompare((($ = y[5]) == null ? void 0 : $.currentSelector) ?? "")) || ((V = R[1]) == null ? void 0 : V.localeCompare(y[1] || "")) || ((ie = R[2]) == null ? void 0 : ie.localeCompare(y[2] || "")) || 0;
        }).map(([, R, y, , E, , x]) => [
          [[(R && gn(R, o)) ?? "", (E == null ? void 0 : E.sort) ?? 0]],
          y,
          !!(x ?? (E == null ? void 0 : E.noMerge))
        ]);
        if (!D.length)
          return;
        const P = D.reverse().map(([R, y, E], x) => {
          if (!E && this.config.mergeSelectors)
            for (let $ = x + 1; $ < N; $++) {
              const M = D[$];
              if (M && !M[2] && (R && M[0] || R == null && M[0] == null) && M[1] === y)
                return R && M[0] && M[0].push(...R), null;
            }
          const U = R ? W(R.sort(($, M) => {
            var V;
            return $[1] - M[1] || ((V = $[0]) == null ? void 0 : V.localeCompare(M[0] || "")) || 0;
          }).map(($) => $[0]).filter(Boolean)) : [];
          return U.length ? `${U.join(`,${u}`)}{${y}}` : y;
        }).filter(Boolean).reverse().join(u);
        if (!O)
          return P;
        const F = O.split(" $$ ");
        return `${F.join("{")}{${u}${P}${u}${"}".repeat(F.length)}`;
      }).filter(Boolean).join(u);
      if (r && (p = [_[w], p].filter(Boolean).join(u)), f && p) {
        let O = typeof f == "object" ? (k = f.cssLayerName) == null ? void 0 : k.call(f, w) : void 0;
        O !== null && (O || (O = w), p = `@layer ${O}{${u}${p}${u}}`);
      }
      const v = l ? "" : `/* layer: ${w} */${u}`;
      return A[w] = p ? v + p : "";
    }, S = (w = C, p) => w.filter((v) => !(p != null && p.includes(v))).map((v) => g(v) || "").filter(Boolean).join(u);
    return {
      get css() {
        return S();
      },
      layers: C,
      matched: m,
      getLayers: S,
      getLayer: g
    };
  }
  async matchVariants(t, n) {
    const s = /* @__PURE__ */ new Set(), o = [];
    let r = n || t, a = !0;
    const l = {
      rawSelector: t,
      theme: this.config.theme,
      generator: this
    };
    for (; a; ) {
      a = !1;
      for (const c of this.config.variants) {
        if (!c.multiPass && s.has(c))
          continue;
        let f = await c.match(r, l);
        if (f) {
          if (L(f)) {
            if (f === r)
              continue;
            f = { matcher: f };
          }
          r = f.matcher, o.unshift(f), s.add(c), a = !0;
          break;
        }
      }
      if (!a)
        break;
      if (o.length > 500)
        throw new Error(`Too many variants applied to "${t}"`);
    }
    return [t, r, o, s];
  }
  applyVariants(t, n = t[4], s = t[1]) {
    const r = n.slice().sort((f, i) => (f.order || 0) - (i.order || 0)).reduceRight(
      (f, i) => (u) => {
        var h, _;
        const d = ((h = i.body) == null ? void 0 : h.call(i, u.entries)) || u.entries, m = Array.isArray(i.parent) ? i.parent : [i.parent, void 0];
        return (i.handle ?? bn)({
          ...u,
          entries: d,
          selector: ((_ = i.selector) == null ? void 0 : _.call(i, u.selector, d)) || u.selector,
          parent: m[0] || u.parent,
          parentOrder: m[1] || u.parentOrder,
          layer: i.layer || u.layer,
          sort: i.sort || u.sort
        }, f);
      },
      (f) => f
    )({
      prefix: "",
      selector: yn(s),
      pseudo: "",
      entries: t[2]
    }), { parent: a, parentOrder: l } = r;
    a != null && l != null && this.parentOrders.set(a, l);
    const c = {
      selector: [
        r.prefix,
        r.selector,
        r.pseudo
      ].join(""),
      entries: r.entries,
      parent: a,
      layer: r.layer,
      sort: r.sort,
      noMerge: r.noMerge
    };
    for (const f of this.config.postprocess)
      f(c);
    return c;
  }
  constructCustomCSS(t, n, s) {
    const o = H(n);
    if (L(o))
      return o;
    const { selector: r, entries: a, parent: l } = this.applyVariants([0, s || t.rawSelector, o, void 0, t.variantHandlers]), c = `${r}{${Q(a)}}`;
    return l ? `${l}{${c}}` : c;
  }
  async parseUtil(t, n, s = !1, o) {
    var i;
    const [r, a, l] = L(t) ? await this.matchVariants(t) : t;
    this.config.details && (n.rules = n.rules ?? []);
    const c = this.config.rulesStaticMap[a];
    if (c && c[1] && (s || !((i = c[2]) != null && i.internal))) {
      this.config.details && n.rules.push(c[3]);
      const u = c[0], d = H(c[1]), m = c[2];
      return L(d) ? [[u, d, m]] : [[u, r, d, m, l]];
    }
    n.variantHandlers = l;
    const { rulesDynamic: f } = this.config;
    for (const [u, d, m, h] of f) {
      if (h != null && h.internal && !s)
        continue;
      let _ = a;
      if (h != null && h.prefix) {
        const g = I(h.prefix);
        if (o) {
          const S = I(o);
          if (!g.some((w) => S.includes(w)))
            continue;
        } else {
          const S = g.find((w) => a.startsWith(w));
          if (S == null)
            continue;
          _ = a.slice(S.length);
        }
      }
      const b = _.match(d);
      if (!b)
        continue;
      const C = await m(b, n);
      if (!C)
        continue;
      this.config.details && n.rules.push([d, m, h]);
      const A = Nt(C).filter((g) => g.length);
      if (A.length)
        return A.map((g) => L(g) ? [u, g, h] : [u, r, g, h, l]);
    }
  }
  stringifyUtil(t, n) {
    if (!t)
      return;
    if (ue(t))
      return [t[0], void 0, t[1], void 0, t[2], this.config.details ? n : void 0, void 0];
    const { selector: s, entries: o, parent: r, layer: a, sort: l, noMerge: c } = this.applyVariants(t), f = Q(o);
    if (!f)
      return;
    const { layer: i, sort: u, ...d } = t[3] ?? {}, m = {
      ...d,
      layer: a ?? i,
      sort: l ?? u
    };
    return [t[0], s, f, r, m, this.config.details ? n : void 0, c];
  }
  async expandShortcut(t, n, s = 5) {
    var l;
    if (s === 0)
      return;
    const o = this.config.details ? (c) => {
      n.shortcuts = n.shortcuts ?? [], n.shortcuts.push(c);
    } : Ht;
    let r, a;
    for (const c of this.config.shortcuts) {
      let f = t;
      if ((l = c[2]) != null && l.prefix) {
        const u = I(c[2].prefix).find((d) => t.startsWith(d));
        if (u == null)
          continue;
        f = t.slice(u.length);
      }
      if (Pt(c)) {
        if (c[0] === f) {
          r = r || c[2], a = c[1], o(c);
          break;
        }
      } else {
        const i = f.match(c[0]);
        if (i && (a = c[1](i, n)), a) {
          r = r || c[2], o(c);
          break;
        }
      }
    }
    if (L(a) && (a = Zt(a.trim()).split(/\s+/g)), !a) {
      const [c, f] = L(t) ? await this.matchVariants(t) : t;
      if (c !== f) {
        const i = await this.expandShortcut(f, n, s - 1);
        i && (a = i[0].map((u) => L(u) ? c.replace(f, u) : u));
      }
    }
    if (a)
      return [
        (await Promise.all(a.map(async (c) => {
          var f;
          return (L(c) ? (f = await this.expandShortcut(c, n, s - 1)) == null ? void 0 : f[0] : void 0) || [c];
        }))).flat(1).filter(Boolean),
        r
      ];
  }
  async stringifyShortcuts(t, n, s, o = { layer: this.config.shortcutsLayer }) {
    var i;
    const r = new Wt(), a = (await Promise.all(W(s).map(async (u) => {
      const d = L(u) ? await this.parseUtil(u, n, !0, o.prefix) : [[Number.POSITIVE_INFINITY, "{inline}", H(u), void 0, []]];
      return !d && this.config.warn && Te(`unmatched utility "${u}" in shortcut "${t[1]}"`), d || [];
    }))).flat(1).filter(Boolean).sort((u, d) => u[0] - d[0]), [l, , c] = t, f = [];
    for (const u of a) {
      if (ue(u)) {
        f.push([u[0], void 0, u[1], void 0, u[2], n, void 0]);
        continue;
      }
      const { selector: d, entries: m, parent: h, sort: _, noMerge: b, layer: C } = this.applyVariants(u, [...u[4], ...c], l);
      r.getFallback(C ?? o.layer, new qt()).getFallback(d, h, [[], u[0]])[0].push([m, !!(b ?? ((i = u[3]) == null ? void 0 : i.noMerge)), _ ?? 0]);
    }
    return f.concat(r.flatMap(
      (u, d) => u.map(([m, h], _, b) => {
        const C = (g, S, w) => {
          const p = Math.max(...w.map((k) => k[1])), v = w.map((k) => k[0]);
          return (g ? [v.flat(1)] : v).map((k) => {
            const O = Q(k);
            if (O)
              return [h, _, O, b, { ...o, noMerge: S, sort: p, layer: d }, n, void 0];
          });
        };
        return [
          [m.filter(([, g]) => g).map(([g, , S]) => [g, S]), !0],
          [m.filter(([, g]) => !g).map(([g, , S]) => [g, S]), !1]
        ].map(([g, S]) => [
          ...C(!1, S, g.filter(([w]) => w.some((p) => p[0] === le))),
          ...C(!0, S, g.filter(([w]) => w.every((p) => p[0] !== le)))
        ]);
      }).flat(2).filter(Boolean)
    ));
  }
  isBlocked(t) {
    return !t || this.config.blocklist.map((n) => Array.isArray(n) ? n[0] : n).some((n) => typeof n == "function" ? n(t) : L(n) ? n === t : n.test(t));
  }
  getBlocked(t) {
    const n = this.config.blocklist.find((s) => {
      const o = Array.isArray(s) ? s[0] : s;
      return typeof o == "function" ? o(t) : L(o) ? o === t : o.test(t);
    });
    return n ? Array.isArray(n) ? n : [n, void 0] : void 0;
  }
}
function hn(e, t) {
  return new mn(e, t);
}
const Le = /\s\$\$\s+/g;
function _n(e) {
  return Le.test(e);
}
function gn(e, t) {
  return _n(e) ? e.replace(Le, t ? ` ${t} ` : " ") : t ? `${t} ${e}` : e;
}
const me = /^\[(.+?)(~?=)"(.*)"\]$/;
function yn(e) {
  return me.test(e) ? e.replace(me, (t, n, s, o) => `[${X(n)}${s}"${X(o)}"]`) : `.${X(e)}`;
}
function bn(e, t) {
  return t(e);
}
var he = { npm_package_dependencies__vueuse_core: "^10.9.0", COREPACK_ROOT: "/Users/arlo/Library/Application Support/fnm/node-versions/v20.12.2/installation/lib/node_modules/corepack", TERM_PROGRAM: "vscode", npm_package_devDependencies__types_splitpanes: "^2.2.6", FNM_LOGLEVEL: "info", NODE: "/Users/arlo/Library/Application Support/fnm/node-versions/v20.12.2/installation/bin/node", INIT_CWD: "/Users/arlo/g/devtools-next/packages/client", TURBO_INVOCATION_DIR: "/Users/arlo/g/devtools-next", npm_package_devDependencies_vite: "^5.2.11", SHELL: "/bin/zsh", TERM: "xterm-256color", npm_config_shamefully_hoist: "true", npm_package_devDependencies_ohash: "^1.1.3", npm_package_devDependencies_floating_vue: "5.2.2", npm_package_dependencies__vue_devtools_shared: "workspace:^", FNM_NODE_DIST_MIRROR: "https://nodejs.org/dist", npm_package_dependencies__unocss_runtime: "^0.60.2", TMPDIR: "/var/folders/6s/79hm4q7x5f982tndmbvckmn80000gn/T/", TERM_PROGRAM_VERSION: "1.88.0", npm_package_devDependencies__vitejs_plugin_vue: "^5.0.4", npm_package_devDependencies_unplugin_vue_components: "^0.27.0", MallocNanoZone: "0", ORIGINAL_XDG_CURRENT_DESKTOP: "undefined", ZDOTDIR: "/Users/arlo", TERM_SESSION_ID: "w0t0p0:730F72ED-5006-40A7-8D8A-3B997BF910AE", npm_config_registry: "https://registry.npmjs.org/", npm_package_private: "true", PNPM_HOME: "/Users/arlo/Library/pnpm", ZSH: "/Users/arlo/.oh-my-zsh", FNM_COREPACK_ENABLED: "false", npm_package_devDependencies__vitejs_plugin_vue_jsx: "^3.1.0", USER: "arlo", npm_package_license: "MIT", LS_COLORS: "di=1;36:ln=35:so=32:pi=33:ex=31:bd=34;46:cd=34;43:su=30;41:sg=30;46:tw=30;42:ow=30;43", COMMAND_MODE: "unix2003", PNPM_SCRIPT_SRC_DIR: "/Users/arlo/g/devtools-next/packages/client", npm_config_strict_peer_dependencies: "", SSH_AUTH_SOCK: "/private/tmp/com.apple.launchd.M7q1yHrUIS/Listeners", npm_package_devDependencies_dayjs: "^1.11.11", __CF_USER_TEXT_ENCODING: "0x1F5:0x19:0x34", npm_execpath: "/Users/arlo/g/devtools-next/node_modules/.pnpm/pnpm@9.1.1/node_modules/pnpm/bin/pnpm.cjs", PAGER: "less", npm_package_devDependencies_unplugin_auto_import: "^0.17.6", npm_package_scripts_build_lib: "vite build --config vite.lib.config.ts", npm_config_frozen_lockfile: "", FNM_VERSION_FILE_STRATEGY: "local", LSCOLORS: "Gxfxcxdxbxegedabagacad", npm_package_dependencies_vue_virtual_scroller: "2.0.0-beta.8", npm_package_dependencies_fuse_js: "^7.0.0", FNM_ARCH: "arm64", PATH: "/Users/arlo/g/devtools-next/packages/client/node_modules/.bin:/Users/arlo/g/devtools-next/node_modules/.pnpm/pnpm@9.1.1/node_modules/pnpm/dist/node-gyp-bin:/Users/arlo/g/devtools-next/node_modules/.bin:/Users/arlo/g/devtools-next/packages/client/node_modules/.bin:/Users/arlo/g/devtools-next/node_modules/.pnpm/pnpm@9.1.1/node_modules/pnpm/dist/node-gyp-bin:/Users/arlo/g/devtools-next/node_modules/.bin:/Users/arlo/g/devtools-next/node_modules/.bin:/Users/arlo/g/devtools-next/node_modules/.pnpm/pnpm@9.1.1/node_modules/pnpm/dist/node-gyp-bin:/Users/arlo/g/devtools-next/node_modules/.bin:/Users/arlo/g/devtools-next/node_modules/.bin:/Users/arlo/.cache/node/corepack/v1/pnpm/9.1.1/dist/node-gyp-bin:/Users/arlo/g/devtools-next/node_modules/.bin:/Users/arlo/Library/Caches/fnm_multishells/6012_1716125490276/bin:/opt/homebrew/bin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Users/arlo/Library/pnpm:/Users/arlo/Library/Caches/fnm_multishells/741_1716123065533/bin:/opt/homebrew/bin:/Applications/WebStorm.app/Contents/MacOS:/Applications/WebStorm.app/Contents/MacOS", npm_package_dependencies__vue_devtools_ui: "workspace:*", npm_package_scripts_stub_lib: "vite build --config vite.lib.config.ts --watch", LaunchInstanceID: "52DCC620-8DA8-4D02-A134-A66BF1A07673", npm_package_dependencies_splitpanes: "^3.1.5", npm_package_author: "webfansplz", COREPACK_ENABLE_DOWNLOAD_PROMPT: "1", USER_ZDOTDIR: "/Users/arlo", __CFBundleIdentifier: "com.microsoft.VSCode", npm_command: "run-script", PWD: "/Users/arlo/g/devtools-next/packages/client", npm_package_exports____: "./dist/*", npm_lifecycle_event: "build:lib", npm_package_devDependencies_vue: "^3.4.27", npm_package_name: "@vue/devtools-client", LANG: "zh_CN.UTF-8", ITERM_PROFILE: "Default", npm_package_devDependencies_simple_git_hooks: "^2.11.1", npm_package_devDependencies_sass: "^1.77.1", npm_package_devDependencies__unocss_reset: "^0.60.2", npm_package_scripts_build: "tsx ./scripts/pre-build.ts && (nr build:lib & vite build)", NODE_PATH: "/Users/arlo/g/devtools-next/node_modules/.pnpm/vite@5.2.11_@types+node@20.12.12_sass@1.77.1_terser@5.26.0/node_modules/vite/bin/node_modules:/Users/arlo/g/devtools-next/node_modules/.pnpm/vite@5.2.11_@types+node@20.12.12_sass@1.77.1_terser@5.26.0/node_modules/vite/node_modules:/Users/arlo/g/devtools-next/node_modules/.pnpm/vite@5.2.11_@types+node@20.12.12_sass@1.77.1_terser@5.26.0/node_modules:/Users/arlo/g/devtools-next/node_modules/.pnpm/node_modules:/Users/arlo/g/devtools-next/node_modules/.pnpm/pnpm@9.1.1/node_modules/pnpm/bin/node_modules:/Users/arlo/g/devtools-next/node_modules/.pnpm/pnpm@9.1.1/node_modules/pnpm/node_modules:/Users/arlo/g/devtools-next/node_modules/.pnpm/pnpm@9.1.1/node_modules:/Users/arlo/g/devtools-next/node_modules/.pnpm/node_modules:/Users/arlo/g/devtools-next/node_modules/.pnpm/@antfu+ni@0.21.12/node_modules/@antfu/ni/bin/node_modules:/Users/arlo/g/devtools-next/node_modules/.pnpm/@antfu+ni@0.21.12/node_modules/@antfu/ni/node_modules:/Users/arlo/g/devtools-next/node_modules/.pnpm/@antfu+ni@0.21.12/node_modules/@antfu/node_modules:/Users/arlo/g/devtools-next/node_modules/.pnpm/@antfu+ni@0.21.12/node_modules:/Users/arlo/g/devtools-next/node_modules/.pnpm/node_modules:/Users/arlo/g/devtools-next/node_modules/.pnpm/pnpm@9.1.1/node_modules/pnpm/bin/node_modules:/Users/arlo/g/devtools-next/node_modules/.pnpm/pnpm@9.1.1/node_modules/pnpm/node_modules:/Users/arlo/g/devtools-next/node_modules/.pnpm/pnpm@9.1.1/node_modules:/Users/arlo/g/devtools-next/node_modules/.pnpm/node_modules:/Users/arlo/g/devtools-next/node_modules/.pnpm/turbo@1.13.3/node_modules/turbo/bin/node_modules:/Users/arlo/g/devtools-next/node_modules/.pnpm/turbo@1.13.3/node_modules/turbo/node_modules:/Users/arlo/g/devtools-next/node_modules/.pnpm/turbo@1.13.3/node_modules:/Users/arlo/g/devtools-next/node_modules/.pnpm/node_modules:/Users/arlo/g/devtools-next/node_modules/.pnpm/pnpm@9.1.1/node_modules/pnpm/bin/node_modules:/Users/arlo/g/devtools-next/node_modules/.pnpm/pnpm@9.1.1/node_modules/pnpm/node_modules:/Users/arlo/g/devtools-next/node_modules/.pnpm/pnpm@9.1.1/node_modules:/Users/arlo/g/devtools-next/node_modules/.pnpm/node_modules:/Users/arlo/g/devtools-next/node_modules/.pnpm/@antfu+ni@0.21.12/node_modules/@antfu/ni/bin/node_modules:/Users/arlo/g/devtools-next/node_modules/.pnpm/@antfu+ni@0.21.12/node_modules/@antfu/ni/node_modules:/Users/arlo/g/devtools-next/node_modules/.pnpm/@antfu+ni@0.21.12/node_modules/@antfu/node_modules:/Users/arlo/g/devtools-next/node_modules/.pnpm/@antfu+ni@0.21.12/node_modules:/Users/arlo/g/devtools-next/node_modules/.pnpm/node_modules:/Users/arlo/Library/pnpm/global/5/.pnpm/@antfu+ni@0.21.12/node_modules/@antfu/ni/bin/node_modules:/Users/arlo/Library/pnpm/global/5/.pnpm/@antfu+ni@0.21.12/node_modules/@antfu/ni/node_modules:/Users/arlo/Library/pnpm/global/5/.pnpm/@antfu+ni@0.21.12/node_modules/@antfu/node_modules:/Users/arlo/Library/pnpm/global/5/.pnpm/@antfu+ni@0.21.12/node_modules:/Users/arlo/Library/pnpm/global/5/.pnpm/node_modules", npm_package_devDependencies_pinia: "^2.1.7", FNM_MULTISHELL_PATH: "/Users/arlo/Library/Caches/fnm_multishells/6012_1716125490276", TURBO_HASH: "0032a3a778c49290", VSCODE_GIT_ASKPASS_EXTRA_ARGS: "", XPC_FLAGS: "0x0", npm_package_devDependencies__unocss_core: "^0.60.2", npm_package_engines_node: ">=v14.21.3", npm_config_node_gyp: "/Users/arlo/.cache/node/corepack/v1/pnpm/9.1.1/dist/node_modules/node-gyp/bin/node-gyp.js", npm_config_side_effects_cache: "", npm_package_dependencies_colord: "^2.9.3", npm_package_devDependencies__iconify_json: "^2.2.210", npm_package_dependencies_minimatch: "^9.0.4", npm_package_version: "7.2.1", XPC_SERVICE_NAME: "0", npm_package_dependencies__vue_devtools_applet: "workspace:^", VSCODE_INJECTION: "1", npm_package_devDependencies_unocss: "^0.60.2", npm_package_dependencies__vue_devtools_core: "workspace:^", npm_package_type: "module", COLORFGBG: "7;0", HOME: "/Users/arlo", SHLVL: "3", VSCODE_GIT_ASKPASS_MAIN: "/Applications/Visual Studio Code.app/Contents/Resources/app/extensions/git/dist/askpass-main.js", npm_package_dependencies_vite_hot_client: "^0.2.3", LC_TERMINAL_VERSION: "3.4.23", FNM_DIR: "/Users/arlo/Library/Application Support/fnm", npm_package_dependencies_vis_network: "^9.1.9", ITERM_SESSION_ID: "w0t0p0:730F72ED-5006-40A7-8D8A-3B997BF910AE", npm_package_peerDependencies_vite: "^3.1.0 || ^4.0.0-0 || ^5.0.0-0", LESS: "-R", LOGNAME: "arlo", npm_lifecycle_script: "vite build --config vite.lib.config.ts", npm_package_dependencies__vue_devtools_kit: "workspace:^", npm_package_dependencies__vueuse_integrations: "^10.9.0", VSCODE_GIT_IPC_HANDLE: "/var/folders/6s/79hm4q7x5f982tndmbvckmn80000gn/T/vscode-git-dffc443db3.sock", npm_config_user_agent: "pnpm/9.1.1 npm/? node/v20.12.2 darwin arm64", FNM_RESOLVE_ENGINES: "false", npm_package_devDependencies__types_node: "^20.12.12", GIT_ASKPASS: "/Applications/Visual Studio Code.app/Contents/Resources/app/extensions/git/dist/askpass.sh", VSCODE_GIT_ASKPASS_NODE: "/Applications/Visual Studio Code.app/Contents/Frameworks/Code Helper (Plugin).app/Contents/MacOS/Code Helper (Plugin)", npm_package_scripts_stub: "nr stub:lib & vite build --watch", LC_TERMINAL: "iTerm2", npm_package_files_0: "dist", npm_package_devDependencies_unplugin: "^1.10.1", npm_package_dependencies_vue_router: "^4.3.2", npm_package_dependencies_shiki: "1.5.2", SECURITYSESSIONID: "186a4", npm_package_dependencies__unocss_preset_icons: "^0.60.2", npm_node_execpath: "/Users/arlo/Library/Application Support/fnm/node-versions/v20.12.2/installation/bin/node", npm_config_shell_emulator: "true", COLORTERM: "truecolor", NODE_ENV: "production" };
const vn = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
), K = Object.freeze({
  rotate: 0,
  vFlip: !1,
  hFlip: !1
}), Ue = Object.freeze({
  ...vn,
  ...K
}), wn = Object.freeze({
  ...Ue,
  body: "",
  hidden: !1
}), Sn = Object.freeze({
  width: null,
  height: null
}), Ie = Object.freeze({
  // Dimensions
  ...Sn,
  // Transformations
  ...K
});
function En(e, t) {
  const n = {};
  !e.hFlip != !t.hFlip && (n.hFlip = !0), !e.vFlip != !t.vFlip && (n.vFlip = !0);
  const s = ((e.rotate || 0) + (t.rotate || 0)) % 4;
  return s && (n.rotate = s), n;
}
function _e(e, t) {
  const n = En(e, t);
  for (const s in wn)
    s in K ? s in e && !(s in n) && (n[s] = K[s]) : s in t ? n[s] = t[s] : s in e && (n[s] = e[s]);
  return n;
}
function xn(e, t) {
  const n = e.icons, s = e.aliases || /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ Object.create(null);
  function r(a) {
    if (n[a])
      return o[a] = [];
    if (!(a in o)) {
      o[a] = null;
      const l = s[a] && s[a].parent, c = l && r(l);
      c && (o[a] = [l].concat(c));
    }
    return o[a];
  }
  return (t || Object.keys(n).concat(Object.keys(s))).forEach(r), o;
}
function ge(e, t, n) {
  const s = e.icons, o = e.aliases || /* @__PURE__ */ Object.create(null);
  let r = {};
  function a(l) {
    r = _e(
      s[l] || o[l],
      r
    );
  }
  return a(t), n.forEach(a), _e(e, r);
}
function An(e, t) {
  if (e.icons[t])
    return ge(e, t, []);
  const n = xn(e, [t])[t];
  return n ? ge(e, t, n) : null;
}
const Cn = /(-?[0-9.]*[0-9]+[0-9.]*)/g, On = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function ye(e, t, n) {
  if (t === 1)
    return e;
  if (n = n || 100, typeof e == "number")
    return Math.ceil(e * t * n) / n;
  if (typeof e != "string")
    return e;
  const s = e.split(Cn);
  if (s === null || !s.length)
    return e;
  const o = [];
  let r = s.shift(), a = On.test(r);
  for (; ; ) {
    if (a) {
      const l = parseFloat(r);
      isNaN(l) ? o.push(r) : o.push(Math.ceil(l * t * n) / n);
    } else
      o.push(r);
    if (r = s.shift(), r === void 0)
      return o.join("");
    a = !a;
  }
}
function kn(e, t = "defs") {
  let n = "";
  const s = e.indexOf("<" + t);
  for (; s >= 0; ) {
    const o = e.indexOf(">", s), r = e.indexOf("</" + t);
    if (o === -1 || r === -1)
      break;
    const a = e.indexOf(">", r);
    if (a === -1)
      break;
    n += e.slice(o + 1, r).trim(), e = e.slice(0, s).trim() + e.slice(a + 1);
  }
  return {
    defs: n,
    content: e
  };
}
function Rn(e, t) {
  return e ? "<defs>" + e + "</defs>" + t : t;
}
function Tn(e, t, n) {
  const s = kn(e);
  return Rn(s.defs, t + s.content + n);
}
const re = (e) => e === "unset" || e === "undefined" || e === "none";
function $n(e, t) {
  const n = {
    ...Ue,
    ...e
  }, s = {
    ...Ie,
    ...t
  }, o = {
    left: n.left,
    top: n.top,
    width: n.width,
    height: n.height
  };
  let r = n.body;
  [n, s].forEach((_) => {
    const b = [], C = _.hFlip, A = _.vFlip;
    let g = _.rotate;
    C ? A ? g += 2 : (b.push(
      "translate(" + (o.width + o.left).toString() + " " + (0 - o.top).toString() + ")"
    ), b.push("scale(-1 1)"), o.top = o.left = 0) : A && (b.push(
      "translate(" + (0 - o.left).toString() + " " + (o.height + o.top).toString() + ")"
    ), b.push("scale(1 -1)"), o.top = o.left = 0);
    let S;
    switch (g < 0 && (g -= Math.floor(g / 4) * 4), g = g % 4, g) {
      case 1:
        S = o.height / 2 + o.top, b.unshift(
          "rotate(90 " + S.toString() + " " + S.toString() + ")"
        );
        break;
      case 2:
        b.unshift(
          "rotate(180 " + (o.width / 2 + o.left).toString() + " " + (o.height / 2 + o.top).toString() + ")"
        );
        break;
      case 3:
        S = o.width / 2 + o.left, b.unshift(
          "rotate(-90 " + S.toString() + " " + S.toString() + ")"
        );
        break;
    }
    g % 2 === 1 && (o.left !== o.top && (S = o.left, o.left = o.top, o.top = S), o.width !== o.height && (S = o.width, o.width = o.height, o.height = S)), b.length && (r = Tn(
      r,
      '<g transform="' + b.join(" ") + '">',
      "</g>"
    ));
  });
  const a = s.width, l = s.height, c = o.width, f = o.height;
  let i, u;
  a === null ? (u = l === null ? "1em" : l === "auto" ? f : l, i = ye(u, c / f)) : (i = a === "auto" ? c : a, u = l === null ? ye(i, f / c) : l === "auto" ? f : l);
  const d = {}, m = (_, b) => {
    re(b) || (d[_] = b.toString());
  };
  m("width", i), m("height", u);
  const h = [o.left, o.top, c, f];
  return d.viewBox = h.join(" "), {
    attributes: d,
    viewBox: h,
    body: r
  };
}
function Mn(e) {
  return e.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function Ln(e) {
  let t = e.startsWith("<svg>") ? e.replace("<svg>", "<svg >") : e;
  return !t.includes(" xmlns:xlink=") && t.includes(" xlink:") && (t = t.replace(
    "<svg ",
    '<svg xmlns:xlink="http://www.w3.org/1999/xlink" '
  )), t.includes(" xmlns=") || (t = t.replace(
    "<svg ",
    '<svg xmlns="http://www.w3.org/2000/svg" '
  )), Mn(t);
}
function Un(e) {
  return e.replace(/(['"])\s*\n\s*([^>\\/\s])/g, "$1 $2").replace(/(["';{}><])\s*\n\s*/g, "$1").replace(/\s*\n\s*/g, " ").replace(/\s+"/g, '"').replace(/="\s+/g, '="').replace(/(\s)+\/>/g, "/>").trim();
}
const In = /\swidth\s*=\s*["']([\w.]+)["']/, Nn = /\sheight\s*=\s*["']([\w.]+)["']/, Z = /<svg\s+/;
function Dn(e, t, n) {
  const s = e.slice(0, e.indexOf(">")), o = (r, a) => {
    const l = a.exec(s), c = l != null, f = t[r];
    return !f && !re(f) && (typeof n == "number" ? n > 0 && (t[r] = `${n}em`) : l && (t[r] = l[1])), c;
  };
  return [o("width", In), o("height", Nn)];
}
async function Ne(e, t, n, s, o, r) {
  const { scale: a, addXmlNs: l = !1 } = s ?? {}, { additionalProps: c = {}, iconCustomizer: f } = (s == null ? void 0 : s.customizations) ?? {}, i = await (o == null ? void 0 : o()) ?? {};
  await (f == null ? void 0 : f(t, n, i)), Object.keys(c).forEach((_) => {
    const b = c[_];
    b != null && (i[_] = b);
  }), r == null || r(i);
  const [u, d] = Dn(e, i, a);
  l && (!e.includes("xmlns=") && !i.xmlns && (i.xmlns = "http://www.w3.org/2000/svg"), !e.includes("xmlns:xlink=") && e.includes("xlink:") && !i["xmlns:xlink"] && (i["xmlns:xlink"] = "http://www.w3.org/1999/xlink"));
  const m = Object.keys(i).map(
    (_) => _ === "width" && u || _ === "height" && d ? null : `${_}="${i[_]}"`
  ).filter((_) => _ != null);
  if (m.length && (e = e.replace(Z, `<svg ${m.join(" ")} `)), s) {
    const { defaultStyle: _, defaultClass: b } = s;
    b && !e.includes("class=") && (e = e.replace(Z, `<svg class="${b}" `)), _ && !e.includes("style=") && (e = e.replace(Z, `<svg style="${_}" `));
  }
  const h = s == null ? void 0 : s.usedProps;
  return h && (Object.keys(c).forEach((_) => {
    const b = i[_];
    b != null && (h[_] = b);
  }), typeof i.width < "u" && i.width !== null && (h.width = i.width), typeof i.height < "u" && i.height !== null && (h.height = i.height)), e;
}
async function be(e, t, n, s) {
  var r;
  let o;
  try {
    if (typeof e == "function")
      o = await e(n);
    else {
      const a = e[n];
      o = typeof a == "function" ? await a() : a;
    }
  } catch (a) {
    console.warn(
      `Failed to load custom icon "${n}" in "${t}":`,
      a
    );
    return;
  }
  if (o) {
    const a = o.indexOf("<svg");
    a > 0 && (o = o.slice(a));
    const { transform: l } = (s == null ? void 0 : s.customizations) ?? {};
    return o = typeof l == "function" ? await l(o, t, n) : o, o.startsWith("<svg") ? await Ne(
      ((r = s == null ? void 0 : s.customizations) == null ? void 0 : r.trimCustomSvg) === !0 ? Un(o) : o,
      t,
      n,
      s,
      void 0
    ) : (console.warn(
      `Custom icon "${n}" in "${t}" is not a valid SVG`
    ), o);
  }
}
async function De(e, t, n, s) {
  let o;
  const { customize: r } = (s == null ? void 0 : s.customizations) ?? {};
  for (const a of n)
    if (o = An(e, a), o) {
      let l = { ...Ie };
      typeof r == "function" && (l = r(l));
      const {
        attributes: { width: c, height: f, ...i },
        body: u
      } = $n(o, l), d = s == null ? void 0 : s.scale;
      return await Ne(
        // DON'T remove space on <svg >
        `<svg >${u}</svg>`,
        t,
        a,
        s,
        () => ({ ...i }),
        (m) => {
          const h = (_, b) => {
            const C = m[_];
            let A;
            if (!re(C)) {
              if (C)
                return;
              typeof d == "number" ? d && (A = `${d}em`) : A = b;
            }
            A ? m[_] = A : delete m[_];
          };
          h("width", c), h("height", f);
        }
      );
    }
}
const je = async (e, t, n) => {
  var o;
  const s = (o = n == null ? void 0 : n.customCollections) == null ? void 0 : o[e];
  if (s)
    if (typeof s == "function") {
      let r;
      try {
        r = await s(t);
      } catch (a) {
        console.warn(
          `Failed to load custom icon "${t}" in "${e}":`,
          a
        );
        return;
      }
      if (r) {
        if (typeof r == "string")
          return await be(
            () => r,
            e,
            t,
            n
          );
        if ("icons" in r) {
          const a = [
            t,
            t.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(),
            t.replace(/([a-z])(\d+)/g, "$1-$2")
          ];
          return await De(
            r,
            e,
            a,
            n
          );
        }
      }
    } else
      return await be(s, e, t, n);
};
function jn(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Pn = [
  "academicons",
  "akar-icons",
  "ant-design",
  "arcticons",
  "basil",
  "bi",
  "bitcoin-icons",
  "bpmn",
  "brandico",
  "bx",
  "bxl",
  "bxs",
  "bytesize",
  "carbon",
  "cbi",
  "charm",
  "ci",
  "cib",
  "cif",
  "cil",
  "circle-flags",
  "circum",
  "clarity",
  "codicon",
  "covid",
  "cryptocurrency-color",
  "cryptocurrency",
  "dashicons",
  "devicon-line",
  "devicon-original",
  "devicon-plain",
  "devicon",
  "ei",
  "el",
  "emblemicons",
  "emojione-monotone",
  "emojione-v1",
  "emojione",
  "entypo-social",
  "entypo",
  "eos-icons",
  "ep",
  "et",
  "eva",
  "f7",
  "fa-brands",
  "fa-regular",
  "fa-solid",
  "fa",
  "fa6-brands",
  "fa6-regular",
  "fa6-solid",
  "fad",
  "fe",
  "feather",
  "file-icons",
  "flag",
  "flagpack",
  "flat-color-icons",
  "flat-ui",
  "flowbite",
  "fluent-emoji-flat",
  "fluent-emoji-high-contrast",
  "fluent-emoji",
  "fluent-mdl2",
  "fluent",
  "fontelico",
  "fontisto",
  "formkit",
  "foundation",
  "fxemoji",
  "gala",
  "game-icons",
  "geo",
  "gg",
  "gis",
  "gravity-ui",
  "gridicons",
  "grommet-icons",
  "guidance",
  "healthicons",
  "heroicons-outline",
  "heroicons-solid",
  "heroicons",
  "humbleicons",
  "ic",
  "icomoon-free",
  "icon-park-outline",
  "icon-park-solid",
  "icon-park-twotone",
  "icon-park",
  "iconamoon",
  "iconoir",
  "icons8",
  "il",
  "ion",
  "iwwa",
  "jam",
  "la",
  "lets-icons",
  "line-md",
  "logos",
  "ls",
  "lucide",
  "mage",
  "majesticons",
  "maki",
  "map",
  "marketeq",
  "material-symbols-light",
  "material-symbols",
  "mdi-light",
  "mdi",
  "medical-icon",
  "memory",
  "meteocons",
  "mi",
  "mingcute",
  "mono-icons",
  "mynaui",
  "nimbus",
  "nonicons",
  "noto-v1",
  "noto",
  "octicon",
  "oi",
  "ooui",
  "openmoji",
  "oui",
  "pajamas",
  "pepicons-pencil",
  "pepicons-pop",
  "pepicons-print",
  "pepicons",
  "ph",
  "pixelarticons",
  "prime",
  "ps",
  "quill",
  "radix-icons",
  "raphael",
  "ri",
  "si-glyph",
  "simple-icons",
  "simple-line-icons",
  "skill-icons",
  "solar",
  "streamline-emojis",
  "streamline",
  "subway",
  "svg-spinners",
  "system-uicons",
  "tabler",
  "tdesign",
  "teenyicons",
  "token-branded",
  "token",
  "topcoat",
  "twemoji",
  "typcn",
  "uil",
  "uim",
  "uis",
  "uit",
  "uiw",
  "unjs",
  "vaadin",
  "vs",
  "vscode-icons",
  "websymbol",
  "whh",
  "wi",
  "wpf",
  "zmdi",
  "zondicons"
];
const Fn = /* @__PURE__ */ jn(Pn), Vn = 3;
function Hn(e) {
  return (t = {}) => {
    const {
      scale: n = 1,
      mode: s = "auto",
      prefix: o = "i-",
      warn: r = !1,
      collections: a,
      extraProperties: l = {},
      customizations: c = {},
      autoInstall: f = !1,
      collectionsNodeResolvePath: i,
      layer: u = "icons",
      unit: d,
      processor: m
    } = t, h = Gn(), _ = {
      addXmlNs: !0,
      scale: n,
      customCollections: a,
      autoInstall: f,
      cwd: i,
      // avoid warn from @iconify/loader: we'll warn below if not found
      warn: void 0,
      customizations: {
        ...c,
        additionalProps: { ...l },
        trimCustomSvg: !0,
        async iconCustomizer(C, A, g) {
          var S;
          await ((S = c.iconCustomizer) == null ? void 0 : S.call(c, C, A, g)), d && (g.width || (g.width = `${n}${d}`), g.height || (g.height = `${n}${d}`));
        }
      }
    };
    let b;
    return {
      name: "@unocss/preset-icons",
      enforce: "pre",
      options: t,
      layers: { icons: -30 },
      rules: [[
        /^([a-z0-9:_-]+)(?:\?(mask|bg|auto))?$/,
        async (C) => {
          let [A, g, S = s] = C, w = "", p = "", v;
          b = b || await e(t);
          const k = {};
          if (g.includes(":"))
            [w, p] = g.split(":"), v = await b(w, p, { ..._, usedProps: k });
          else {
            const N = g.split(/-/g);
            for (let D = Vn; D >= 1 && (w = N.slice(0, D).join("-"), p = N.slice(D).join("-"), v = await b(w, p, { ..._, usedProps: k }), !v); D--)
              ;
          }
          if (!v) {
            r && !h.isESLint && Te(`failed to load icon "${A}"`);
            return;
          }
          let O;
          const T = `url("data:image/svg+xml;utf8,${Ln(v)}")`;
          return S === "auto" && (S = v.includes("currentColor") ? "mask" : "bg"), S === "mask" ? O = {
            "--un-icon": T,
            "-webkit-mask": "var(--un-icon) no-repeat",
            mask: "var(--un-icon) no-repeat",
            "-webkit-mask-size": "100% 100%",
            "mask-size": "100% 100%",
            "background-color": "currentColor",
            // for Safari https://github.com/elk-zone/elk/pull/264
            color: "inherit",
            ...k
          } : O = {
            background: `${T} no-repeat`,
            "background-size": "100% 100%",
            "background-color": "transparent",
            ...k
          }, m == null || m(O, { collection: w, icon: p, svg: v, mode: S }), O;
        },
        { layer: u, prefix: o }
      ]]
    };
  };
}
function Pe(e, t) {
  const n = /* @__PURE__ */ new Map();
  function s(o) {
    if (Fn.includes(o))
      return n.has(o) || n.set(o, e(`${t}@iconify-json/${o}/icons.json`)), n.get(o);
  }
  return async (o, r, a) => {
    let l = await je(o, r, a);
    if (l)
      return l;
    const c = await s(o);
    if (c) {
      const f = [
        r,
        r.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(),
        r.replace(/([a-z])(\d+)/g, "$1-$2")
      ];
      l = await De(c, o, f, a);
    }
    return l;
  };
}
function Gn() {
  const e = typeof process < "u" && process.stdout && !process.versions.deno, t = e && !!he.VSCODE_CWD, n = e && !!he.ESLINT;
  return {
    isNode: e,
    isVSCode: t,
    isESLint: n
  };
}
function Bn(e) {
  return Pe(Lt, e);
}
const zn = Hn(async (e) => {
  const t = e == null ? void 0 : e.customFetch, n = e == null ? void 0 : e.cdn;
  return t && n ? Pe(t, n) : n ? Bn(n) : je;
});
function qn(e) {
  return e.replace(/-(\w)/g, (t, n) => n ? n.toUpperCase() : "");
}
function ve(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}
function we(e) {
  return e.replace(/(?:^|\B)([A-Z])/g, "-$1").toLowerCase();
}
var Se = ["Webkit", "Moz", "ms"];
function Wn(e) {
  const t = {};
  function n(s) {
    const o = t[s];
    if (o)
      return o;
    let r = qn(s);
    if (r !== "filter" && r in e)
      return t[s] = we(r);
    r = ve(r);
    for (let a = 0; a < Se.length; a++) {
      const l = `${Se[a]}${r}`;
      if (l in e)
        return t[s] = we(ve(l));
    }
    return s;
  }
  return ({ entries: s }) => s.forEach((o) => {
    o[0].startsWith("--") || (o[0] = n(o[0]));
  });
}
function Kn(e) {
  return e.replace(/&amp;/g, "&").replace(/&gt;/g, ">").replace(/&lt;/g, "<");
}
function Jn(e = {}) {
  var P, F, R;
  if (typeof window > "u") {
    console.warn("@unocss/runtime been used in non-browser environment, skipped.");
    return;
  }
  const t = window, n = window.document, s = () => n.documentElement, o = t.__unocss || {}, r = Object.assign({}, e, o.runtime), a = r.defaults || {}, l = r.cloakAttribute ?? "un-cloak";
  r.autoPrefix && (a.postprocess = I(a.postprocess)).unshift(Wn(n.createElement("div").style)), (P = r.configResolved) == null || P.call(r, o, a);
  const c = hn(o, a), f = (y) => r.inject ? r.inject(y) : s().prepend(y), i = () => r.rootElement ? r.rootElement() : n.body, u = /* @__PURE__ */ new Map();
  let d = !0, m = /* @__PURE__ */ new Set(), h, _, b = [];
  const C = () => new Promise((y) => {
    b.push(y), _ != null && clearTimeout(_), _ = setTimeout(() => S().then(() => {
      const E = b;
      b = [], E.forEach((x) => x());
    }), 0);
  });
  function A(y) {
    if (y.nodeType !== 1)
      return;
    const E = y;
    E.hasAttribute(l) && E.removeAttribute(l), E.querySelectorAll(`[${l}]`).forEach((x) => {
      x.removeAttribute(l);
    });
  }
  function g(y, E) {
    let x = u.get(y);
    if (!x)
      if (x = n.createElement("style"), x.setAttribute("data-unocss-runtime-layer", y), u.set(y, x), E == null)
        f(x);
      else {
        const U = g(E), $ = U.parentNode;
        $ ? $.insertBefore(x, U.nextSibling) : f(x);
      }
    return x;
  }
  async function S() {
    const y = await c.generate(m);
    return y.layers.reduce((E, x) => (g(x, E).innerHTML = y.getLayer(x) ?? "", x), void 0), m = y.matched, {
      ...y,
      getStyleElement: (E) => u.get(E),
      getStyleElements: () => u
    };
  }
  async function w(y) {
    const E = m.size;
    await c.applyExtractors(y, void 0, m), E !== m.size && await C();
  }
  async function p(y = i()) {
    const E = y && y.outerHTML;
    E && (await w(`${E} ${Kn(E)}`), A(s()), A(y));
  }
  const v = new MutationObserver((y) => {
    d || y.forEach(async (E) => {
      if (E.target.nodeType !== 1)
        return;
      const x = E.target;
      for (const U of u)
        if (x === U[1])
          return;
      if (E.type === "childList")
        E.addedNodes.forEach(async (U) => {
          if (U.nodeType !== 1)
            return;
          const $ = U;
          h && !h($) || (await w($.outerHTML), A($));
        });
      else {
        if (h && !h(x))
          return;
        if (E.attributeName !== l) {
          const U = Array.from(x.attributes).map((M) => M.value ? `${M.name}="${M.value}"` : M.name).join(" "), $ = `<${x.tagName.toLowerCase()} ${U}>`;
          await w($);
        }
        x.hasAttribute(l) && x.removeAttribute(l);
      }
    });
  });
  let k = !1;
  function O() {
    var E, x;
    if (k)
      return;
    const y = (E = r.observer) != null && E.target ? r.observer.target() : i();
    y && (v.observe(y, {
      childList: !0,
      subtree: !0,
      attributes: !0,
      attributeFilter: (x = r.observer) == null ? void 0 : x.attributeFilter
    }), k = !0);
  }
  function T() {
    r.bypassDefined && Xn(c.blocked), p(), O();
  }
  function N() {
    n.readyState === "loading" ? t.addEventListener("DOMContentLoaded", T) : T();
  }
  const D = t.__unocss_runtime = t.__unocss_runtime = {
    version: c.version,
    uno: c,
    async extract(y) {
      L(y) || (y.forEach((E) => m.add(E)), y = ""), await w(y);
    },
    extractAll: p,
    inspect(y) {
      h = y;
    },
    toggleObserver(y) {
      y === void 0 ? d = !d : d = !!y, !k && !d && N();
    },
    update: S,
    presets: ((F = t.__unocss_runtime) == null ? void 0 : F.presets) ?? {}
  };
  ((R = r.ready) == null ? void 0 : R.call(r, D)) !== !1 && (d = !1, N());
}
function Xn(e = /* @__PURE__ */ new Set()) {
  for (let t = 0; t < document.styleSheets.length; t++) {
    const n = document.styleSheets[t];
    let s;
    try {
      if (s = n.cssRules || n.rules, !s)
        continue;
      Array.from(s).flatMap((o) => {
        var r;
        return ((r = o.selectorText) == null ? void 0 : r.split(/,/g)) || [];
      }).forEach((o) => {
        o && (o = o.trim(), o.startsWith(".") && (o = o.slice(1)), e.add(o));
      });
    } catch {
      continue;
    }
  }
  return e;
}
Jn({
  defaults: {
    presets: [
      zn({
        prefix: ["i-", ""],
        collections: {},
        cdn: "https://esm.sh/",
        scale: 1.2,
        extraProperties: {
          display: "inline-block",
          "vertical-align": "middle"
        }
      })
    ]
  },
  bypassDefined: !0
});
